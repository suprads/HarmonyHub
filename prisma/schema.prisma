// Some of the schema here is managed/created by Better Auth and its plugins.

generator client {
  provider        = "prisma-client"
  output          = "../generated/prisma"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider = "postgresql"
}

model User {
  /// Default generated by Better Auth
  id                     String          @id
  email                  String          @unique
  emailVerified          Boolean         @default(false)
  /// User's chosen display name.
  name                   String
  handle                 String          @unique
  image                  String?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  sessions               Session[]
  accounts               Account[]
  friends                Friend[]        @relation("Friends")
  friendedBy             Friend[]        @relation("FriendedBy")
  likes                  Like[]
  friendRequestsReceived FriendRequest[] @relation("FriendRequestsReceived")
  friendRequestsSent     FriendRequest[] @relation("FriendRequestsSent")

  @@map("User")
}

model Session {
  /// Default generated by Better Auth
  id        String   @id
  expiresAt DateTime
  /// The session token, which is also used as the session cookie.
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("Session")
}

model Account {
  /// Default generated by Better Auth
  id                    String    @id
  userId                String
  /// The ID of the account as provided by the SSO or equal to userId for credential accounts
  accountId             String
  providerId            String
  password              String?
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  lastLoginAt           DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("Account")
}

model Verification {
  /// Default generated by Better Auth
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("Verification")
}

model Artist {
  id        BigInt   @id @default(autoincrement())
  name      String   @unique
  createdAt DateTime @default(now())
  tracks    Track[]
}

model Album {
  id          BigInt    @id @default(autoincrement())
  title       String
  releaseDate DateTime?
  createdAt   DateTime  @default(now())
  tracks      Track[]
}

model Track {
  id         BigInt        @id @default(autoincrement())
  title      String
  durationMs Int?
  explicit   Boolean       @default(false)
  createdAt  DateTime      @default(now())
  artistId   BigInt
  albumId    BigInt?
  likes      Like[]
  album      Album?        @relation(fields: [albumId], references: [id])
  artist     Artist        @relation(fields: [artistId], references: [id])
  sources    TrackSource[]

  @@unique([title, artistId, albumId])
}

model TrackSource {
  id              BigInt   @id @default(autoincrement())
  provider        Provider
  providerTrackId String
  raw             Json?
  trackId         BigInt
  track           Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([provider, providerTrackId])
  @@unique([trackId, provider])
}

model Friend {
  friend       User     @relation("Friends", fields: [friendId], references: [id], onDelete: Cascade)
  friendId     String
  friendedBy   User     @relation("FriendedBy", fields: [friendedById], references: [id], onDelete: Cascade)
  friendedById String
  createdAt    DateTime @default(now())

  @@id([friendId, friendedById])
}

model FriendRequest {
  receiver   User     @relation("FriendRequestsReceived", fields: [receiverId], references: [id])
  receiverId String
  sender     User     @relation("FriendRequestsSent", fields: [senderId], references: [id])
  senderId   String
  createdAt  DateTime @default(now())

  @@id([senderId, receiverId])
}

model Like {
  userId    String
  trackId   BigInt
  createdAt DateTime @default(now())
  track     Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, trackId])
}

enum Provider {
  SPOTIFY
  APPLE
  YTMUSIC
  SOUNDCLOUD
}

enum AuthProvider {
  LOCAL
  SPOTIFY
  GOOGLE
  APPLE
}
